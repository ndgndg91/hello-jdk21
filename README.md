# Hello Concurrency with JDk21

## Mutex
뮤텍스는 일반적으로 하나의 스레드만이 임계 영역에 접근할 수 있게 하는 락 메커니즘.
* 뮤텍스를 소유한 스레드만이 해당 자원을 사용할 수 있고, 다른 스레드는 뮤텍스가 해제될 때까지 대기한다.
* 뮤텍스는 소유권 개념을 가지고 있어, 뮤텍스를 잠그는(lock) 스레드만이 해당 뮤텍스를 해제(unlock)할 수 있음.
* 명시적 락 관리: 스레드가 락을 명시적으로 획득하고 해제해야 한다. lock()과 unlock() 메서드를 사용합니다.
* 조건 변수 선택: ReentrantLock 을 사용하는 경우, Condition 객체를 생성하여 복잡한 동기화 패턴을 구현할 수 있다.
* 공정성 설정 가능: ReentrantLock 생성자에서 공정성을 설정할 수 있어, 대기하는 스레드 중 가장 오래 기다린 스레드가 락을 획득할 수 있다.

ReentrantLock 클래스가 자바에서 뮤텍스의 역할을 수행할 수 있다.
- synchronized 키워드가 제공하는 락 기능을 보다 확장하여 더 많은 기능과 유연성을 제공. 
- ReentrantLock 의 주요 특징 중 하나는 재진입 가능성(reentrancy). 
- 재진입 가능한 락은 같은 스레드가 여러 번 락을 획득할 수 있도록 허용하며, 락을 해제하는 횟수가 락을 획득한 횟수와 같아야 한다.

### ReentrantLock 의 주요 기능
- 재진입 가능: 동일한 스레드가 이미 획득한 락을 추가적으로 다시 획득할 수 있다. 이 때, 스레드는 락을 획득한 횟수만큼 락을 해제해야 한다.
- 인터럽트 처리: ReentrantLock 을 사용하면 대기 중인 스레드를 인터럽트할 수 있어, 데드락과 같은 상황을 피할 수 있다. lockInterruptibly() 메소드를 사용하여 락을 획득하려고 할 때 스레드를 인터럽트할 수 있다.
- 시도 제한: tryLock() 메소드를 사용하면 락을 획득할 수 없을 때 바로 반환하거나, 지정된 시간 동안 대기하고 시간이 초과되면 포기할 수 있다. 이는 락을 기다리는 시간을 제어할 수 있게 한다.
- 공정성: ReentrantLock 은 생성자에 true 를 전달하여 공정 모드로 설정할 수 있다. 공정 모드에서는 대기 중인 스레드 중 가장 오래 기다린 스레드가 락을 획득할 수 있는 기회를 얻는다. 그러나 이 모드는 성능 저하를 초래할 수 있다.

## Semaphore
세마포어는 지정된 수의 허용된 스레드만이 동시에 임계 영역에 접근할 수 있게 합니다.
* 세마포어의 값은 사용 가능한 자원의 수를 나타낸다
* 스레드가 자원을 요청할 때마다(acquire) 세마포어의 값이 감소하고, 자원을 반환할 때마다(release) 값이 증가한다.
* 세마포어는 주로 두 가지 유형:
  - 카운터 기반: 세마포어는 내부적으로 카운터를 사용하여 동시에 접근할 수 있는 스레드 수를 제어한다.
  - 바이너리 세마포어는 0 또는 1의 값만을 가지며, 뮤텍스와 유사하게 동작한다.
* 세마포어는 소유권이 없으므로, 잠금을 획득하지 않는 스레드가 잠금을 해제할 수 있다.
* 유연성: 카운팅 세마포어를 사용하면 여러 스레드가 동시에 임계 영역에 접근할 수 있다.
* monitor 의 synchronized 키워드와 다르게 세마포어는 보다 명시적인 락 관리를 요구.

## Monitor
* 자바에서 모니터는 synchronized 키워드를 사용하여 구현.
* 모니터는 특정 객체에 대한 접근을 동기화하며, 객체의 임계 영역(critical section)을 안전하게 보호.
  * 자동 잠금 관리: synchronized 블록에 진입할 때 자동으로 락을 획득하고, 블록을 벗어날 때 자동으로 락을 해제.
  * 재진입 가능: 같은 스레드가 이미 락을 획득한 객체에 대해 synchronized 블록을 다시 진입할 수 있다.
  * 조건 변수 지원: 모든 자바 객체는 wait(), notify(), notifyAll() 메서드를 통해 조건 변수를 지원.
  * 이 메서드들은 synchronized 블록 내에서 사용되어 스레드 간의 통신을 가능하게 한다.

## CountDownLatch
CountDownLatch 는 한 번 사용되고 초기화되지 않는 일회성 바리어. 특정 수의 이벤트가 발생할 때까지 하나 이상의 스레드가 대기하도록 설계되었다.

### 특징 및 사용법
- CountDownLatch 는 생성 시 지정된 횟수만큼 이벤트(메서드 호출)가 발생하기를 기다린다.
- 각 이벤트는 countDown() 메서드 호출로 표현되며, 이 호출은 래치의 카운트를 감소시킨다.
- await() 메서드를 호출한 스레드들은 래치의 카운트가 0이 될 때까지 대기한다.
- 모든 필수 이벤트가 발생하고 카운트가 0이 되면, 대기 중인 모든 스레드가 동시에 실행을 재개한다.

### 예시
모든 부품이 조립되기를 기다리는 제품 조립 라인에서 각 부품 조립 완료 시 countDown()을 호출하고, 최종 조립 단계는 await()에서 대기한다.

## CyclicBarrier
CyclicBarrier 는 재사용이 가능한 바리어로, 지정된 수의 스레드가 서로 도달할 때까지 대기하도록 설계되었다.

### 특징 및 사용법
- CyclicBarrier 는 생성 시 참여해야 할 스레드의 수를 지정받는다.
- 모든 스레드가 await() 메서드를 호출할 때까지 각 스레드는 바리어에서 대기한다.
- 마지막 스레드가 await()을 호출하면, 선택적으로 실행할 수 있는 바리어 액션(예: 스레드 중 하나가 실행하는 코드 조각)이 실행되고, 이후 모든 스레드가 동시에 진행을 재개한다.
- CyclicBarrier 는 리셋되어 다시 사용될 수 있다.

### 예시
- 멀티 스테이지 이벤트에서 모든 참가자가 다음 단계로 넘어가기 전에 특정 체크포인트에서 모두 모이는 상황.


# 차이점
## Mutex, Monitor
- 뮤텍스와 모니터는 주로 데이터의 동시 접근을 제어하여 데이터 무결성을 보호한다. 뮤텍스는 소유가 가능한 잠금이며, 모니터(synchronized)는 객체나 메서드 단위로 동기화를 제공.

## Semaphore 
- 세마포어는 동시에 리소스에 접근할 수 있는 스레드의 수를 제한한다. 리소스의 제한된 접근을 관리하는 데 사용된다.

##  CountDownLatch, CyclicBarrier 
- 특정 포인트에서 스레드의 동작을 조정하기 위해 사용. 데이터 접근을 제어하기보다는 스레드의 흐름과 실행 순서를 조정하는 데 초점을 맞춘다.